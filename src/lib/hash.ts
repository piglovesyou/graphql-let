import crypto from 'crypto';
import { readFileSync } from 'fs';
import { EOL } from 'os';

const shouldCareNewline = EOL !== '\n';
const RegexCRLF = /\r\n/g;
const leadingLettersForFileHash = '/* ';
const hexHashLength = 40;

function normalizeNewline(input: string | Buffer): string {
  const str = Buffer.isBuffer(input) ? input.toString() : input;
  if (shouldCareNewline) return str.replace(RegexCRLF, '\n');
  return str;
}

export function createHash(s: string | Buffer): string {
  return crypto.createHash('sha1').update(normalizeNewline(s)).digest('hex');
}

export function createHashFromBuffers(ss: (string | Buffer)[]): string {
  const hash = crypto.createHash('sha1');
  for (const s of ss) hash.update(normalizeNewline(s));
  return hash.digest('hex');
}

export function withHash(sourceHash: string, content: string): string {
  return `${leadingLettersForFileHash}${sourceHash}
 * This file is automatically generated by graphql-let. */

${content}`;
}

export function readHash(filePath: string): string | null {
  try {
    // Sync is the fastest for a limited sized file to read hash
    // https://gist.github.com/piglovesyou/537a8157ba691e8e9e023263bfc7838d
    const content = readFileSync(filePath, 'utf-8');
    const hash = content.slice(
      leadingLettersForFileHash.length,
      leadingLettersForFileHash.length + hexHashLength,
    );
    if (hash) return hash;
    return null;
  } catch (error) {
    if (error.code === 'ENOENT') return null;
    throw error;
  }
}
